package com.digitalml.rest.resources.codegentest.service;
    	
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import java.net.URL;

import org.apache.commons.collections.CollectionUtils;

import java.lang.Object;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.ws.rs.core.SecurityContext;
import java.security.AccessControlException;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import javax.validation.constraints.*;

import org.dozer.DozerBeanMapper;
import org.dozer.Mapper;

// Import any model objects used by the interface

import com.digitalml.rest.resources.codegentest.*;

/**
 * Service: MoneySend
 * 120
 *
 * This service has been automatically generated by Ignite
 *
 * @author admin
 * @version V3
 *
 */

public abstract class MoneySendService {

	private static final Logger LOGGER = LoggerFactory.getLogger(MoneySendService.class);

	// Required for JSR-303 validation
	static private ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();

	protected static Mapper mapper;

	static {
		URL configFile = MoneySendService.class.getResource("MoneySendServiceMappings.xml");
		if (configFile != null) {

			List<String> mappingFiles = new ArrayList<String>();
			mappingFiles.add(configFile.toExternalForm());
			mapper = new DozerBeanMapper(mappingFiles);

		} else {
			mapper = new DozerBeanMapper(); // Use default wildcard mappings only
		}
	}

	protected boolean checkPermissions(SecurityContext securityContext) throws AccessControlException {
		return true;
	}

	/**
	Implements method inquireCardMapping
	
		This resource will allow a customer to view the existing Card Mappings associated with the customer&#x27;s MoneySend
subscription using an API call. 
A customer has the ability to view card mappings created under the customer&#x27;s MoneySend
subscription. In addition, the Card Mapping Inquire will provide certain data necessary to submit a MoneySend Transfer
transaction, Update Card Mapping, or Delete Card Mapping if that information is not already available.Card Mappings are
stored in a secure encrypted environment which is a PCI compliant data storage facility managed by Mastercard.

	*/
	public InquireCardMappingReturnDTO inquireCardMapping(SecurityContext securityContext, InquireCardMappingInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method inquireCardMapping");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access inquireCardMapping");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access inquireCardMapping");

		InquireCardMappingReturnDTO returnValue = new InquireCardMappingReturnDTO();
        InquireCardMappingCurrentStateDTO currentState = new InquireCardMappingCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method createCardMapping
	
		Allows a customer to create a card mapping for their MoneySend subscription using an API call.
 Creation of a Card
Mapping allows a Mastercard customer to associate their card account to a unique identifier or ‘alias&#x27; within the
customer&#x27;s MoneySend enrollment profile. This unique identifier can be used to send or receive funds via the MoneySend
service without sharing card account information.This also enables MoneySend to execute transactions between senders and
receivers who bank with different Mastercard Members while protecting the card account information of each customer.Card
Mappings are stored in a secure encrypted environment which is a PCI compliant data storage facility managed by
Mastercard.
	*/
	public CreateCardMappingReturnDTO createCardMapping(SecurityContext securityContext, CreateCardMappingInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method createCardMapping");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access createCardMapping");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access createCardMapping");

		CreateCardMappingReturnDTO returnValue = new CreateCardMappingReturnDTO();
        CreateCardMappingCurrentStateDTO currentState = new CreateCardMappingCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method transferPost1
	
		Use the Transfer resource to transfer funds to a recipient with an eligible Mastercard card account.
	*/
	public TransferPost1ReturnDTO transferPost1(SecurityContext securityContext, TransferPost1InputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method transferPost1");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access transferPost1");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access transferPost1");

		TransferPost1ReturnDTO returnValue = new TransferPost1ReturnDTO();
        TransferPost1CurrentStateDTO currentState = new TransferPost1CurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method deleteSubscriber
	
		This resource allows the removal of a Subscriber ID profile, along with all Card Mappings, using an API call. If a
customer chooses to change their Subscriber ID, the current Subscriber ID should be deleted and a new Subscriber ID
created. This resource would also be used if the Subscriber ID was no longer needed for participation in the MoneySend
service. 
	*/
	public DeleteSubscriberReturnDTO deleteSubscriber(SecurityContext securityContext, DeleteSubscriberInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method deleteSubscriber");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access deleteSubscriber");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access deleteSubscriber");

		DeleteSubscriberReturnDTO returnValue = new DeleteSubscriberReturnDTO();
        DeleteSubscriberCurrentStateDTO currentState = new DeleteSubscriberCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method checkPANEligibility
	
		The Primary Account Number (PAN) is the card number. The Mastercard MoneySend Platform is a global offering, however
there may be specific countries, receiving institutions (RIs) or account ranges that are blocked from participation in
the offering. The Card is eligible if it hasn&#x27;t been blocked for receiving a MoneySend payment. PAN eligibility provides
the capability to check the sending and receiving card for a transaction in a single call.  This resource enables you to
verify that a cardholder&#x27;s account is eligible to receive MoneySend transactions and provides additional information for
sending and receiving cards: the Interbank Card Association (ICA) code of the issuer, currency code (alpha and numeric),
country code (alpha and numeric), brand acceptance code, and brand product code will be returned. 
	*/
	public CheckPANEligibilityReturnDTO checkPANEligibility(SecurityContext securityContext, CheckPANEligibilityInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method checkPANEligibility");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access checkPANEligibility");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access checkPANEligibility");

		CheckPANEligibilityReturnDTO returnValue = new CheckPANEligibilityReturnDTO();
        CheckPANEligibilityCurrentStateDTO currentState = new CheckPANEligibilityCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method transferPost
	
		Use the Transfer resource to transfer funds to a recipient with an eligible Mastercard card account.
	*/
	public TransferPostReturnDTO transferPost(SecurityContext securityContext, TransferPostInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method transferPost");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access transferPost");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access transferPost");

		TransferPostReturnDTO returnValue = new TransferPostReturnDTO();
        TransferPostCurrentStateDTO currentState = new TransferPostCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method sanctionScore
	
		MoneySend™ Sanction Screening ServiceMastercard® provides the capability for financial institutions to screen a Sender&#x27;s
or Recipient&#x27;s name against OFAC&#x27;s Specially Designated Nationals and Blocked Persons List (OFAC SDN List), and other
select lists from the sending and receiving countries. Originating Institutions (OIs) and Receiving Institutions (RIs)
that would like to screen the sender or recipient&#x27;s name can now take advantage of the MoneySend Sanction Screening
Service.The service is intended to help financial institutions meet Anti-Money Laundering (AML) compliance
obligations.How it works1. The OI or RI sends the sender or recipient name and country to screen. 2. Based on the
likelihood of a match, a score between 000 and 100 is generated per name. A higher score indicates a closer match to
names on the applicable screening list, while lower scores indicate a less likely match.The service uses advanced
matching algorithms:Proprietary artificial intelligence and advanced algorithms such as: pattern matching, phonetics
algorithms, field matching, and fuzzy logic.Phonetics algorithms deal with the different spelling and variations form of
a name: Meier and Meyer or Sinclair and St. Clair, etc.Fuzzy logics deals with nicknames or short forms of given names:
Bob for Robert, Liz for Elizabeth, or a variation of the surname- Westy for West.3. The service returns the list name of
the list with the highest score*. 4. OIs and RIs may use the score to determine if the sender or recipient meets their
AML obligations.*Screening lists are available on the Publications page, List of Manuals, on Mastercard Connect.
Screening lists will be set by region. The regions sanctions lists are configurable. Use Sanction Scoring inquiry to get
the sanction screening score which will help to effectively manage money transfers
	*/
	public SanctionScoreReturnDTO sanctionScore(SecurityContext securityContext, SanctionScoreInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method sanctionScore");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access sanctionScore");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access sanctionScore");

		SanctionScoreReturnDTO returnValue = new SanctionScoreReturnDTO();
        SanctionScoreCurrentStateDTO currentState = new SanctionScoreCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method transferReversalPost
	
		The Transfer Reversal resource is a request to reverse a previously submitted Transfer and is only available in
extremely limited circumstances. Transfer reversal must be submitted within 24 hours of processing the original transfer
request - this applies to the payment transaction only. Reversal ProcessingThe following limited reversals or
corrections are permitted for MoneySend Payment Transactions:1.Capability to reverse a Funding Transaction and credit
the refund to the sender&#x27;s Funding Account.2.Capability to process an online reversal request within one calendar day of
the date the MoneySend Payment Transaction was authorized only in the event of a documented clerical error.3.Capability
to ensure that the Receiving Institution has approved the MoneySend Payment Transaction reversal request, prior to
crediting the refund to the sender&#x27;s Funding Account.  Use this resource to reverse a previously submitted Transfer. 
	*/
	public TransferReversalPostReturnDTO transferReversalPost(SecurityContext securityContext, TransferReversalPostInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method transferReversalPost");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access transferReversalPost");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access transferReversalPost");

		TransferReversalPostReturnDTO returnValue = new TransferReversalPostReturnDTO();
        TransferReversalPostCurrentStateDTO currentState = new TransferReversalPostCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method updateCardMapping
	
		This resource will allow a customer to update an existing Card Mapping associated with the customer&#x27;s MoneySend
subscription using an API call. The information provided in the update request becomes the newly-updated record.  A
customer has the ability to change certain information in an existing card mapping in order to keep the account
information current. The data fields available for update are: Alias, Default Indicator, Account information, Cardholder
Name, and Cardholder Address information. The account mapping is uniquely identified by a combination of Subscriber ID,
Subscriber Type, Account Usage, and Alias data elements.Card Mappings are stored in a secure encrypted environment which
is a PCI compliant data storage facility managed by Mastercard.
	*/
	public UpdateCardMappingReturnDTO updateCardMapping(SecurityContext securityContext, UpdateCardMappingInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method updateCardMapping");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access updateCardMapping");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access updateCardMapping");

		UpdateCardMappingReturnDTO returnValue = new UpdateCardMappingReturnDTO();
        UpdateCardMappingCurrentStateDTO currentState = new UpdateCardMappingCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}

	/**
	Implements method deleteCardMapping
	
		This resource will allow a customer to delete an existing Card Mapping associated with the customer&#x27;s MoneySend
subscription using an API call.
	*/
	public DeleteCardMappingReturnDTO deleteCardMapping(SecurityContext securityContext, DeleteCardMappingInputParametersDTO inputs)  {

		if (LOGGER.isDebugEnabled())
			LOGGER.debug("Entered method deleteCardMapping");

		// Do any security checks
		if (securityContext == null)
			throw new AccessControlException("No SecurityContext available so cannot access deleteCardMapping");

		if (!checkPermissions(securityContext))
			throw new AccessControlException("Insufficient permissions to access deleteCardMapping");

		DeleteCardMappingReturnDTO returnValue = new DeleteCardMappingReturnDTO();
        DeleteCardMappingCurrentStateDTO currentState = new DeleteCardMappingCurrentStateDTO();
        
        // Setup the inputs for the first process step
        mapper.map(inputs, currentState.getInputs());
        
		Object returnDTO = null;
		return returnValue;
	}


    // Supporting Use Case and Process methods

	public abstract InquireCardMappingCurrentStateDTO inquireCardMappingUseCaseStep1(InquireCardMappingCurrentStateDTO currentState);


	public abstract CreateCardMappingCurrentStateDTO createCardMappingUseCaseStep1(CreateCardMappingCurrentStateDTO currentState);


	public abstract TransferPost1CurrentStateDTO transferPost1UseCaseStep1(TransferPost1CurrentStateDTO currentState);


	public abstract DeleteSubscriberCurrentStateDTO deleteSubscriberUseCaseStep1(DeleteSubscriberCurrentStateDTO currentState);


	public abstract CheckPANEligibilityCurrentStateDTO checkPANEligibilityUseCaseStep1(CheckPANEligibilityCurrentStateDTO currentState);


	public abstract TransferPostCurrentStateDTO transferPostUseCaseStep1(TransferPostCurrentStateDTO currentState);


	public abstract SanctionScoreCurrentStateDTO sanctionScoreUseCaseStep1(SanctionScoreCurrentStateDTO currentState);


	public abstract TransferReversalPostCurrentStateDTO transferReversalPostUseCaseStep1(TransferReversalPostCurrentStateDTO currentState);


	public abstract UpdateCardMappingCurrentStateDTO updateCardMappingUseCaseStep1(UpdateCardMappingCurrentStateDTO currentState);


	public abstract DeleteCardMappingCurrentStateDTO deleteCardMappingUseCaseStep1(DeleteCardMappingCurrentStateDTO currentState);


// Supporting Exception classes

// Supporting DTO classes


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation inquireCardMapping.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class InquireCardMappingCurrentStateDTO {
		
		private InquireCardMappingInputParametersDTO inputs;
		private InquireCardMappingReturnDTO returnObject;
		private InquireCardMappingReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public InquireCardMappingCurrentStateDTO() {
			initialiseDTOs();
		}

		public InquireCardMappingCurrentStateDTO(InquireCardMappingInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public InquireCardMappingInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(InquireCardMappingReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public InquireCardMappingReturnStatusDTO getErrorState() {
			return errorState;
		}

		public InquireCardMappingReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new InquireCardMappingInputParametersDTO();
			returnObject = new InquireCardMappingReturnDTO();
			errorState = new InquireCardMappingReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation inquireCardMapping
	 */
	public static class InquireCardMappingReturnDTO {
		private com.digitalml.rest.resources.codegentest.Inquiremapping_58_wrapper responseWrapper200InquireCardMapping;
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	    responseWrapper200InquireCardMapping = new com.digitalml.rest.resources.codegentest.Inquiremapping_58_wrapper();
    	}

		public com.digitalml.rest.resources.codegentest.Inquiremapping_58_wrapper getResponseWrapper200InquireCardMapping() {
			return responseWrapper200InquireCardMapping;
		}

		public void setResponseWrapper200InquireCardMapping(com.digitalml.rest.resources.codegentest.Inquiremapping_58_wrapper responseWrapper200InquireCardMapping) {
			this.responseWrapper200InquireCardMapping = responseWrapper200InquireCardMapping;
		}

	};

	/**
	 * Holds the return value for the operation inquireCardMapping when an exception has been thrown.
	 */
	public static class InquireCardMappingReturnStatusDTO {

		private String exceptionMessage;

		public InquireCardMappingReturnStatusDTO() {
		}

		public InquireCardMappingReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation inquireCardMapping in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class InquireCardMappingInputParametersDTO {


		private com.digitalml.rest.resources.codegentest.Inquiremappingrequest_57_wrapper inquireMappingRequest;

		public com.digitalml.rest.resources.codegentest.Inquiremappingrequest_57_wrapper getInquireMappingRequest() {
			return inquireMappingRequest;
		}

		public void setInquireMappingRequest(com.digitalml.rest.resources.codegentest.Inquiremappingrequest_57_wrapper inquireMappingRequest) {
			this.inquireMappingRequest = inquireMappingRequest;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<InquireCardMappingInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<InquireCardMappingInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<InquireCardMappingInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation createCardMapping.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class CreateCardMappingCurrentStateDTO {
		
		private CreateCardMappingInputParametersDTO inputs;
		private CreateCardMappingReturnDTO returnObject;
		private CreateCardMappingReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public CreateCardMappingCurrentStateDTO() {
			initialiseDTOs();
		}

		public CreateCardMappingCurrentStateDTO(CreateCardMappingInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public CreateCardMappingInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(CreateCardMappingReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public CreateCardMappingReturnStatusDTO getErrorState() {
			return errorState;
		}

		public CreateCardMappingReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new CreateCardMappingInputParametersDTO();
			returnObject = new CreateCardMappingReturnDTO();
			errorState = new CreateCardMappingReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation createCardMapping
	 */
	public static class CreateCardMappingReturnDTO {
		private com.digitalml.rest.resources.codegentest.Createmapping_55_wrapper responseWrapper200CreateCardMapping;
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	    responseWrapper200CreateCardMapping = new com.digitalml.rest.resources.codegentest.Createmapping_55_wrapper();
    	}

		public com.digitalml.rest.resources.codegentest.Createmapping_55_wrapper getResponseWrapper200CreateCardMapping() {
			return responseWrapper200CreateCardMapping;
		}

		public void setResponseWrapper200CreateCardMapping(com.digitalml.rest.resources.codegentest.Createmapping_55_wrapper responseWrapper200CreateCardMapping) {
			this.responseWrapper200CreateCardMapping = responseWrapper200CreateCardMapping;
		}

	};

	/**
	 * Holds the return value for the operation createCardMapping when an exception has been thrown.
	 */
	public static class CreateCardMappingReturnStatusDTO {

		private String exceptionMessage;

		public CreateCardMappingReturnStatusDTO() {
		}

		public CreateCardMappingReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation createCardMapping in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class CreateCardMappingInputParametersDTO {


		private com.digitalml.rest.resources.codegentest.Createmappingrequest_52_wrapper createMappingRequest;

		public com.digitalml.rest.resources.codegentest.Createmappingrequest_52_wrapper getCreateMappingRequest() {
			return createMappingRequest;
		}

		public void setCreateMappingRequest(com.digitalml.rest.resources.codegentest.Createmappingrequest_52_wrapper createMappingRequest) {
			this.createMappingRequest = createMappingRequest;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<CreateCardMappingInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<CreateCardMappingInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<CreateCardMappingInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation transferPost1.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class TransferPost1CurrentStateDTO {
		
		private TransferPost1InputParametersDTO inputs;
		private TransferPost1ReturnDTO returnObject;
		private TransferPost1ReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public TransferPost1CurrentStateDTO() {
			initialiseDTOs();
		}

		public TransferPost1CurrentStateDTO(TransferPost1InputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public TransferPost1InputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(TransferPost1ReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public TransferPost1ReturnStatusDTO getErrorState() {
			return errorState;
		}

		public TransferPost1ReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new TransferPost1InputParametersDTO();
			returnObject = new TransferPost1ReturnDTO();
			errorState = new TransferPost1ReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation transferPost1
	 */
	public static class TransferPost1ReturnDTO {
		private com.digitalml.rest.resources.codegentest.Transfer_29_wrapper responseWrapper200TransferPost1;
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	    responseWrapper200TransferPost1 = new com.digitalml.rest.resources.codegentest.Transfer_29_wrapper();
    	}

		public com.digitalml.rest.resources.codegentest.Transfer_29_wrapper getResponseWrapper200TransferPost1() {
			return responseWrapper200TransferPost1;
		}

		public void setResponseWrapper200TransferPost1(com.digitalml.rest.resources.codegentest.Transfer_29_wrapper responseWrapper200TransferPost1) {
			this.responseWrapper200TransferPost1 = responseWrapper200TransferPost1;
		}

	};

	/**
	 * Holds the return value for the operation transferPost1 when an exception has been thrown.
	 */
	public static class TransferPost1ReturnStatusDTO {

		private String exceptionMessage;

		public TransferPost1ReturnStatusDTO() {
		}

		public TransferPost1ReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation transferPost1 in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class TransferPost1InputParametersDTO {


		private com.digitalml.rest.resources.codegentest.Fundingrequestv3_18_wrapper fundingRequestV3;

		public com.digitalml.rest.resources.codegentest.Fundingrequestv3_18_wrapper getFundingRequestV3() {
			return fundingRequestV3;
		}

		public void setFundingRequestV3(com.digitalml.rest.resources.codegentest.Fundingrequestv3_18_wrapper fundingRequestV3) {
			this.fundingRequestV3 = fundingRequestV3;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<TransferPost1InputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<TransferPost1InputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<TransferPost1InputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation deleteSubscriber.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class DeleteSubscriberCurrentStateDTO {
		
		private DeleteSubscriberInputParametersDTO inputs;
		private DeleteSubscriberReturnDTO returnObject;
		private DeleteSubscriberReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public DeleteSubscriberCurrentStateDTO() {
			initialiseDTOs();
		}

		public DeleteSubscriberCurrentStateDTO(DeleteSubscriberInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public DeleteSubscriberInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(DeleteSubscriberReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public DeleteSubscriberReturnStatusDTO getErrorState() {
			return errorState;
		}

		public DeleteSubscriberReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new DeleteSubscriberInputParametersDTO();
			returnObject = new DeleteSubscriberReturnDTO();
			errorState = new DeleteSubscriberReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation deleteSubscriber
	 */
	public static class DeleteSubscriberReturnDTO {
		private com.digitalml.rest.resources.codegentest.Deletesubscriberid_75_wrapper responseWrapper200DeleteSubscriber;
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	    responseWrapper200DeleteSubscriber = new com.digitalml.rest.resources.codegentest.Deletesubscriberid_75_wrapper();
    	}

		public com.digitalml.rest.resources.codegentest.Deletesubscriberid_75_wrapper getResponseWrapper200DeleteSubscriber() {
			return responseWrapper200DeleteSubscriber;
		}

		public void setResponseWrapper200DeleteSubscriber(com.digitalml.rest.resources.codegentest.Deletesubscriberid_75_wrapper responseWrapper200DeleteSubscriber) {
			this.responseWrapper200DeleteSubscriber = responseWrapper200DeleteSubscriber;
		}

	};

	/**
	 * Holds the return value for the operation deleteSubscriber when an exception has been thrown.
	 */
	public static class DeleteSubscriberReturnStatusDTO {

		private String exceptionMessage;

		public DeleteSubscriberReturnStatusDTO() {
		}

		public DeleteSubscriberReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation deleteSubscriber in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class DeleteSubscriberInputParametersDTO {


		private com.digitalml.rest.resources.codegentest.Deletesubscriberidrequest_74_wrapper deleteSubscriberIdRequest;

		public com.digitalml.rest.resources.codegentest.Deletesubscriberidrequest_74_wrapper getDeleteSubscriberIdRequest() {
			return deleteSubscriberIdRequest;
		}

		public void setDeleteSubscriberIdRequest(com.digitalml.rest.resources.codegentest.Deletesubscriberidrequest_74_wrapper deleteSubscriberIdRequest) {
			this.deleteSubscriberIdRequest = deleteSubscriberIdRequest;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<DeleteSubscriberInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<DeleteSubscriberInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<DeleteSubscriberInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation checkPANEligibility.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class CheckPANEligibilityCurrentStateDTO {
		
		private CheckPANEligibilityInputParametersDTO inputs;
		private CheckPANEligibilityReturnDTO returnObject;
		private CheckPANEligibilityReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public CheckPANEligibilityCurrentStateDTO() {
			initialiseDTOs();
		}

		public CheckPANEligibilityCurrentStateDTO(CheckPANEligibilityInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public CheckPANEligibilityInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(CheckPANEligibilityReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public CheckPANEligibilityReturnStatusDTO getErrorState() {
			return errorState;
		}

		public CheckPANEligibilityReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new CheckPANEligibilityInputParametersDTO();
			returnObject = new CheckPANEligibilityReturnDTO();
			errorState = new CheckPANEligibilityReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation checkPANEligibility
	 */
	public static class CheckPANEligibilityReturnDTO {
		private com.digitalml.rest.resources.codegentest.Paneligibility_41_wrapper responseWrapper200CheckPANEligibility;
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	    responseWrapper200CheckPANEligibility = new com.digitalml.rest.resources.codegentest.Paneligibility_41_wrapper();
    	}

		public com.digitalml.rest.resources.codegentest.Paneligibility_41_wrapper getResponseWrapper200CheckPANEligibility() {
			return responseWrapper200CheckPANEligibility;
		}

		public void setResponseWrapper200CheckPANEligibility(com.digitalml.rest.resources.codegentest.Paneligibility_41_wrapper responseWrapper200CheckPANEligibility) {
			this.responseWrapper200CheckPANEligibility = responseWrapper200CheckPANEligibility;
		}

	};

	/**
	 * Holds the return value for the operation checkPANEligibility when an exception has been thrown.
	 */
	public static class CheckPANEligibilityReturnStatusDTO {

		private String exceptionMessage;

		public CheckPANEligibilityReturnStatusDTO() {
		}

		public CheckPANEligibilityReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation checkPANEligibility in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class CheckPANEligibilityInputParametersDTO {


		private com.digitalml.rest.resources.codegentest.Paneligibilityrequest_38_wrapper panEligibilityRequest;

		public com.digitalml.rest.resources.codegentest.Paneligibilityrequest_38_wrapper getPanEligibilityRequest() {
			return panEligibilityRequest;
		}

		public void setPanEligibilityRequest(com.digitalml.rest.resources.codegentest.Paneligibilityrequest_38_wrapper panEligibilityRequest) {
			this.panEligibilityRequest = panEligibilityRequest;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<CheckPANEligibilityInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<CheckPANEligibilityInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<CheckPANEligibilityInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation transferPost.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class TransferPostCurrentStateDTO {
		
		private TransferPostInputParametersDTO inputs;
		private TransferPostReturnDTO returnObject;
		private TransferPostReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public TransferPostCurrentStateDTO() {
			initialiseDTOs();
		}

		public TransferPostCurrentStateDTO(TransferPostInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public TransferPostInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(TransferPostReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public TransferPostReturnStatusDTO getErrorState() {
			return errorState;
		}

		public TransferPostReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new TransferPostInputParametersDTO();
			returnObject = new TransferPostReturnDTO();
			errorState = new TransferPostReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation transferPost
	 */
	public static class TransferPostReturnDTO {
		private com.digitalml.rest.resources.codegentest.Transfer_14_wrapper responseWrapper200TransferPost;
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	    responseWrapper200TransferPost = new com.digitalml.rest.resources.codegentest.Transfer_14_wrapper();
    	}

		public com.digitalml.rest.resources.codegentest.Transfer_14_wrapper getResponseWrapper200TransferPost() {
			return responseWrapper200TransferPost;
		}

		public void setResponseWrapper200TransferPost(com.digitalml.rest.resources.codegentest.Transfer_14_wrapper responseWrapper200TransferPost) {
			this.responseWrapper200TransferPost = responseWrapper200TransferPost;
		}

	};

	/**
	 * Holds the return value for the operation transferPost when an exception has been thrown.
	 */
	public static class TransferPostReturnStatusDTO {

		private String exceptionMessage;

		public TransferPostReturnStatusDTO() {
		}

		public TransferPostReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation transferPost in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class TransferPostInputParametersDTO {


		private com.digitalml.rest.resources.codegentest.Paymentrequestv3_1_wrapper paymentRequestV3;

		public com.digitalml.rest.resources.codegentest.Paymentrequestv3_1_wrapper getPaymentRequestV3() {
			return paymentRequestV3;
		}

		public void setPaymentRequestV3(com.digitalml.rest.resources.codegentest.Paymentrequestv3_1_wrapper paymentRequestV3) {
			this.paymentRequestV3 = paymentRequestV3;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<TransferPostInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<TransferPostInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<TransferPostInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation sanctionScore.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class SanctionScoreCurrentStateDTO {
		
		private SanctionScoreInputParametersDTO inputs;
		private SanctionScoreReturnDTO returnObject;
		private SanctionScoreReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public SanctionScoreCurrentStateDTO() {
			initialiseDTOs();
		}

		public SanctionScoreCurrentStateDTO(SanctionScoreInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public SanctionScoreInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(SanctionScoreReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public SanctionScoreReturnStatusDTO getErrorState() {
			return errorState;
		}

		public SanctionScoreReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new SanctionScoreInputParametersDTO();
			returnObject = new SanctionScoreReturnDTO();
			errorState = new SanctionScoreReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation sanctionScore
	 */
	public static class SanctionScoreReturnDTO {
		private com.digitalml.rest.resources.codegentest.Sanctionscoreserviceresponse_51_wrapper responseWrapper200SanctionScore;
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	    responseWrapper200SanctionScore = new com.digitalml.rest.resources.codegentest.Sanctionscoreserviceresponse_51_wrapper();
    	}

		public com.digitalml.rest.resources.codegentest.Sanctionscoreserviceresponse_51_wrapper getResponseWrapper200SanctionScore() {
			return responseWrapper200SanctionScore;
		}

		public void setResponseWrapper200SanctionScore(com.digitalml.rest.resources.codegentest.Sanctionscoreserviceresponse_51_wrapper responseWrapper200SanctionScore) {
			this.responseWrapper200SanctionScore = responseWrapper200SanctionScore;
		}

	};

	/**
	 * Holds the return value for the operation sanctionScore when an exception has been thrown.
	 */
	public static class SanctionScoreReturnStatusDTO {

		private String exceptionMessage;

		public SanctionScoreReturnStatusDTO() {
		}

		public SanctionScoreReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation sanctionScore in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class SanctionScoreInputParametersDTO {


		private com.digitalml.rest.resources.codegentest.Sanctionscoreservicerequest_50_wrapper sanctionScoreServiceRequest;

		public com.digitalml.rest.resources.codegentest.Sanctionscoreservicerequest_50_wrapper getSanctionScoreServiceRequest() {
			return sanctionScoreServiceRequest;
		}

		public void setSanctionScoreServiceRequest(com.digitalml.rest.resources.codegentest.Sanctionscoreservicerequest_50_wrapper sanctionScoreServiceRequest) {
			this.sanctionScoreServiceRequest = sanctionScoreServiceRequest;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<SanctionScoreInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<SanctionScoreInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<SanctionScoreInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation transferReversalPost.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class TransferReversalPostCurrentStateDTO {
		
		private TransferReversalPostInputParametersDTO inputs;
		private TransferReversalPostReturnDTO returnObject;
		private TransferReversalPostReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public TransferReversalPostCurrentStateDTO() {
			initialiseDTOs();
		}

		public TransferReversalPostCurrentStateDTO(TransferReversalPostInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public TransferReversalPostInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(TransferReversalPostReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public TransferReversalPostReturnStatusDTO getErrorState() {
			return errorState;
		}

		public TransferReversalPostReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new TransferReversalPostInputParametersDTO();
			returnObject = new TransferReversalPostReturnDTO();
			errorState = new TransferReversalPostReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation transferReversalPost
	 */
	public static class TransferReversalPostReturnDTO {
		private com.digitalml.rest.resources.codegentest.Transferreversal_34_wrapper responseWrapper200TransferReversalPost;
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	    responseWrapper200TransferReversalPost = new com.digitalml.rest.resources.codegentest.Transferreversal_34_wrapper();
    	}

		public com.digitalml.rest.resources.codegentest.Transferreversal_34_wrapper getResponseWrapper200TransferReversalPost() {
			return responseWrapper200TransferReversalPost;
		}

		public void setResponseWrapper200TransferReversalPost(com.digitalml.rest.resources.codegentest.Transferreversal_34_wrapper responseWrapper200TransferReversalPost) {
			this.responseWrapper200TransferReversalPost = responseWrapper200TransferReversalPost;
		}

	};

	/**
	 * Holds the return value for the operation transferReversalPost when an exception has been thrown.
	 */
	public static class TransferReversalPostReturnStatusDTO {

		private String exceptionMessage;

		public TransferReversalPostReturnStatusDTO() {
		}

		public TransferReversalPostReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation transferReversalPost in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class TransferReversalPostInputParametersDTO {


		private com.digitalml.rest.resources.codegentest.Transferreversalrequest_33_wrapper transferReversalRequest;

		public com.digitalml.rest.resources.codegentest.Transferreversalrequest_33_wrapper getTransferReversalRequest() {
			return transferReversalRequest;
		}

		public void setTransferReversalRequest(com.digitalml.rest.resources.codegentest.Transferreversalrequest_33_wrapper transferReversalRequest) {
			this.transferReversalRequest = transferReversalRequest;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<TransferReversalPostInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<TransferReversalPostInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<TransferReversalPostInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation updateCardMapping.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class UpdateCardMappingCurrentStateDTO {
		
		private UpdateCardMappingInputParametersDTO inputs;
		private UpdateCardMappingReturnDTO returnObject;
		private UpdateCardMappingReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public UpdateCardMappingCurrentStateDTO() {
			initialiseDTOs();
		}

		public UpdateCardMappingCurrentStateDTO(UpdateCardMappingInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public UpdateCardMappingInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(UpdateCardMappingReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public UpdateCardMappingReturnStatusDTO getErrorState() {
			return errorState;
		}

		public UpdateCardMappingReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new UpdateCardMappingInputParametersDTO();
			returnObject = new UpdateCardMappingReturnDTO();
			errorState = new UpdateCardMappingReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation updateCardMapping
	 */
	public static class UpdateCardMappingReturnDTO {
		private com.digitalml.rest.resources.codegentest.Updatemapping_70_wrapper responseWrapper200UpdateCardMapping;
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	    responseWrapper200UpdateCardMapping = new com.digitalml.rest.resources.codegentest.Updatemapping_70_wrapper();
    	}

		public com.digitalml.rest.resources.codegentest.Updatemapping_70_wrapper getResponseWrapper200UpdateCardMapping() {
			return responseWrapper200UpdateCardMapping;
		}

		public void setResponseWrapper200UpdateCardMapping(com.digitalml.rest.resources.codegentest.Updatemapping_70_wrapper responseWrapper200UpdateCardMapping) {
			this.responseWrapper200UpdateCardMapping = responseWrapper200UpdateCardMapping;
		}

	};

	/**
	 * Holds the return value for the operation updateCardMapping when an exception has been thrown.
	 */
	public static class UpdateCardMappingReturnStatusDTO {

		private String exceptionMessage;

		public UpdateCardMappingReturnStatusDTO() {
		}

		public UpdateCardMappingReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation updateCardMapping in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class UpdateCardMappingInputParametersDTO {


		private int mappingId;

		private com.digitalml.rest.resources.codegentest.Updatemappingrequest_67_wrapper updateMappingRequest;

		public int getMappingId() {
			return mappingId;
		}

		public void setMappingId(int mappingId) {
			this.mappingId = mappingId;
		}

		public com.digitalml.rest.resources.codegentest.Updatemappingrequest_67_wrapper getUpdateMappingRequest() {
			return updateMappingRequest;
		}

		public void setUpdateMappingRequest(com.digitalml.rest.resources.codegentest.Updatemappingrequest_67_wrapper updateMappingRequest) {
			this.updateMappingRequest = updateMappingRequest;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<UpdateCardMappingInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<UpdateCardMappingInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<UpdateCardMappingInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};


	/**
	 * Provides a DTO to hold the current state of the orchestration for the operation deleteCardMapping.
	 * This allows the state to be easily passed in method calls.
	 */
	public static class DeleteCardMappingCurrentStateDTO {
		
		private DeleteCardMappingInputParametersDTO inputs;
		private DeleteCardMappingReturnDTO returnObject;
		private DeleteCardMappingReturnStatusDTO errorState;
		// DTOs for orchestration
		
		public DeleteCardMappingCurrentStateDTO() {
			initialiseDTOs();
		}

		public DeleteCardMappingCurrentStateDTO(DeleteCardMappingInputParametersDTO inputs) {
			initialiseDTOs();
			this.inputs = inputs;
		}
		
		// Add extra DTOs for steps
		public DeleteCardMappingInputParametersDTO getInputs() {
			return inputs;
		}

		
		public void setErrorState(DeleteCardMappingReturnStatusDTO errorState) {
			this.errorState = errorState;
		}

		public DeleteCardMappingReturnStatusDTO getErrorState() {
			return errorState;
		}

		public DeleteCardMappingReturnDTO getReturnObject() {
			return returnObject;
		}
		
		private void initialiseDTOs() {
			inputs = new DeleteCardMappingInputParametersDTO();
			returnObject = new DeleteCardMappingReturnDTO();
			errorState = new DeleteCardMappingReturnStatusDTO();
		
		}			
	};

	/**
	 * Holds the return value for the operation deleteCardMapping
	 */
	public static class DeleteCardMappingReturnDTO {
		private com.digitalml.rest.resources.codegentest.Deletemapping_72_wrapper responseWrapper200DeleteCardMapping;
		
		{
    		initialiseDTO();
    	}
    	
    	private void initialiseDTO() {
    	    responseWrapper200DeleteCardMapping = new com.digitalml.rest.resources.codegentest.Deletemapping_72_wrapper();
    	}

		public com.digitalml.rest.resources.codegentest.Deletemapping_72_wrapper getResponseWrapper200DeleteCardMapping() {
			return responseWrapper200DeleteCardMapping;
		}

		public void setResponseWrapper200DeleteCardMapping(com.digitalml.rest.resources.codegentest.Deletemapping_72_wrapper responseWrapper200DeleteCardMapping) {
			this.responseWrapper200DeleteCardMapping = responseWrapper200DeleteCardMapping;
		}

	};

	/**
	 * Holds the return value for the operation deleteCardMapping when an exception has been thrown.
	 */
	public static class DeleteCardMappingReturnStatusDTO {

		private String exceptionMessage;

		public DeleteCardMappingReturnStatusDTO() {
		}

		public DeleteCardMappingReturnStatusDTO(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}



		public String getExceptionMessage() {
			return exceptionMessage;
		}

		public void setExceptionMessage(String exceptionMessage) {
			this.exceptionMessage = exceptionMessage;
		}
	};

	/**
	 * Holds the input parameters for the operation deleteCardMapping in a single DTO which aids
	 * validation and allows the inputs to be easily passed in method calls.
	 */
	public static class DeleteCardMappingInputParametersDTO {


		private int mappingId;

		public int getMappingId() {
			return mappingId;
		}

		public void setMappingId(int mappingId) {
			this.mappingId = mappingId;
		}


		public boolean validate() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<DeleteCardMappingInputParametersDTO>> errors = validator.validate(this);
			return CollectionUtils.isEmpty(errors);
		}

		public List<String> validateReport() {
			Validator validator = validatorFactory.getValidator();
			Set<ConstraintViolation<DeleteCardMappingInputParametersDTO>> errors = validator.validate(this);

			List<String> results = new ArrayList<String>();
			if (CollectionUtils.isNotEmpty(errors))
				for (ConstraintViolation<DeleteCardMappingInputParametersDTO> error : errors) {
					StringBuffer sb = new StringBuffer();
					sb.append(error.getMessage());
					results.add(sb.toString());
				}

			return results;
		}
	};

}